# 第四章：设备驱动 (函数与闭包)

> 随着接入设备增多，直接写 `if-else` 会让代码变得难以维护。我们需要将特定设备的控制逻辑封装成“驱动函数”，形成统一可复用的控制层。

## 本章目标

*   学会用函数封装设备控制指令。
*   理解高阶函数在场景编排中的价值。
*   建立“业务与硬件解耦”的设计意识。

## 1. 封装控制指令 (定义函数)

将“打开空调”这个动作封装起来，无论在哪个房间，调用方式都一样。

```cangjie
// 定义驱动函数
func setAirConditioner(mode: String, temp: Int64) {
    println("📡 发送指令 -> 空调: 模式[${mode}], 设定温度[${temp}]")
    // 这里可以是真实的硬件 I/O 操作
}

main() {
    // 业务逻辑调用，无需关心底层硬件细节
    setAirConditioner("制冷", 24)
}
```

## 2. 场景模式 (高阶函数)

用户常定义“离家模式”或“观影模式”。这些模式本质上是一系列指令的组合。我们可以编写一个“场景执行器”。

```cangjie
// 场景执行器：接收一个函数作为具体场景逻辑
func executeScene(sceneName: String, action: () -> Unit) {
    println(">>> 正在激活场景: ${sceneName}")
    action() // 执行传入的逻辑
    println(">>> 场景激活完毕\n")
}

main() {
    // 定义离家模式 (Lambda)
    let awayMode = { =>
        println(" - 关闭所有灯光")
        println(" - 开启安防摄像头")
        println(" - 锁定大门")
    }

    // 执行
    executeScene("离家模式", awayMode)
}
```

通过函数，我们将“做什么”（业务）和“怎么做”（实现）分离开来，这是现代软件工程的基石。

代码要点：

`func` 默认返回 `Unit`，适合封装设备指令等“只产生副作用”的动作；参数类型明确后，调用端的意图也更清晰。
高阶函数 `executeScene` 接收 `() -> Unit` 的函数参数，场景逻辑可以像数据一样传递，形成可插拔的流程编排。
Lambda `{ => ... }` 会捕获外部变量（如场景配置），因此能够在不改动执行器的情况下组合新场景。

## 工程化提示

*   设备驱动函数应保持幂等性，避免重复指令造成异常。
*   场景模式建议记录执行日志，便于回放与故障分析。
*   高阶函数的参数命名要直观，减少调用端误用。

## 小试身手

1. 添加 `setLight` 函数并加入“观影模式”场景。
2. 将 `executeScene` 改为返回执行结果，标记成功或失败。

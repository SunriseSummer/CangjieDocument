# 程序结构

仓颉程序由一个或多个源文件（后缀为 `.cj`）组成。本章将介绍仓颉程序的整体结构、变量定义、作用域以及值类型与引用类型的核心概念。

## 1. 源文件结构与入口

### 顶层作用域
在仓颉源文件中，不被任何大括号 `{}` 包围的代码区域称为**顶层作用域**。
在顶层作用域中，您可以定义：
- **全局变量**: 在整个包内（受可见性修饰符限制）可访问的变量。
- **全局函数**: 如 `main` 函数或其他工具函数。
- **自定义类型**: 如 `struct`、`class`、`enum`、`interface` 等。

### 程序入口: `main`
可执行程序的入口是 `main` 函数。
- 必须定义在顶层作用域。
- 不需要 `func` 关键字修饰。
- 可以无参数，也可以接受 `Array<String>` 类型的命令行参数。
- 返回值可以是 `Unit` 或整数类型。

<!-- compile -->
```cangjie
// example.cj
let globalVar = 2023 // 全局变量

// 自定义类型
struct MyStruct {}
class MyClass {}

// 程序入口
main() {
    println("Hello, Cangjie!")
    println(globalVar)
}
```

## 2. 变量定义

变量是程序中存储数据的基本单元。在仓颉中，变量由**修饰符**、**名字**、**类型**和**值**组成。

### 基本语法
```text
修饰符 变量名: 类型 = 初始值
```

### 修饰符与可变性
仓颉强制要求在定义变量时指定其可变性：

| 修饰符 | 说明 | 示例 |
| :--- | :--- | :--- |
| **`let`** | **不可变变量**。一旦初始化，其值（绑定关系）不能再改变。 | `let a = 10` |
| **`var`** | **可变变量**。初始化后，可以再次赋值。 | `var b = 20` |
| **`const`** | **编译时常量**。必须在声明时初始化，且值必须在编译期确定。 | `const PI = 3.14` |

<!-- verify -->
```cangjie
main() {
    let a: Int64 = 10
    var b: Int64 = 20

    // a = 11 // ❌ 编译错误：不可变变量不能重新赋值
    b = 21    // ✅ 正确

    println("${a}, ${b}")
}
```

### 类型推断
如果提供了初始值，编译器通常可以自动推断变量的类型，此时可以省略类型标注。
```cangjie
let x = 100       // 推断为 Int64
let name = "Cangjie" // 推断为 String
```

### 初始化规则
- **全局变量**: 必须在声明时初始化。
- **局部变量**: 可以先声明后初始化，但在**使用前必须完成初始化**。

<!-- verify -->
```cangjie
main() {
    let text: String // 声明但未初始化
    text = "Hello"   // 初始化
    println(text)    // 使用（必须在初始化之后）
}
```

## 3. 作用域 (Scope)

作用域决定了变量、函数等名字的可见范围和生命周期。仓颉主要通过大括号 `{}` 来划分作用域。

### 嵌套规则
1.  **内层可见外层**: 内层作用域可以直接访问外层作用域定义的元素。
2.  **外层不可见内层**: 外层作用域无法访问内层作用域定义的元素。
3.  **遮蔽 (Shadowing)**: 内层作用域可以定义与外层同名的元素，此时在内层中，新定义会遮蔽外层定义。

<!-- verify -->
```cangjie
let element = "Global" // 顶层作用域

main() {
    println(element) // 输出 "Global"

    let element = 100 // main 函数作用域，遮蔽了全局变量

    if (element > 0) {
        let element = 2023 // if 块作用域，遮蔽了 main 函数变量
        println(element)   // 输出 2023
    }

    println(element) // 输出 100 (回到了 main 函数作用域)
}
```

## 4. 值类型与引用类型

理解**值类型**和**引用类型**的区别对于编写正确的仓颉程序至关重要。

### 区别概览

| 特性 | 值类型 (Value Type) | 引用类型 (Reference Type) |
| :--- | :--- | :--- |
| **典型代表** | 基础数据类型 (Int, Bool...), `struct` | `class`, `Array` |
| **赋值行为** | **拷贝副本**。赋值给新变量时，会复制一份完整的数据。 | **传递引用**。赋值给新变量时，只复制引用（指针），指向同一个对象。 |
| **数据共享** | 变量间数据独立，互不影响。 | 多个变量共享同一份数据，修改一个会影响另一个。 |

### 示例对比

<!-- verify -->
```cangjie
// struct 是值类型
struct Copy {
    var data = 100
}

// class 是引用类型
class Share {
    var data = 100
}

main() {
    // 值类型行为
    let c1 = Copy()
    var c2 = c1      // 发生拷贝
    c2.data = 200    // 修改 c2 不会影响 c1
    println("Value Type: c1=${c1.data}, c2=${c2.data}") // 100, 200

    // 引用类型行为
    let s1 = Share()
    let s2 = s1      // 传递引用，s1 和 s2 指向同一个对象
    s2.data = 200    // 修改 s2 会影响 s1
    println("Ref Type:   s1=${s1.data}, s2=${s2.data}") // 200, 200
}
```

> **💡 提示**:
> - 对于值类型，使用 `let` 定义的变量，其自身及其成员都不可变。
> - 对于引用类型，使用 `let` 定义的变量，仅表示**引用关系**不可变（不能指向别的对象），但对象内部的成员（如果是 `var`）是可以修改的。
